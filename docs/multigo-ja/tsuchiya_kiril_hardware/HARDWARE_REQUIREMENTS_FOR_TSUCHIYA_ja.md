# ハードウェア要件パッケージ（土屋さん + キリルさん向け）

**文書種類:** 実装ガイド
**対象読者:** 土屋（機械/電気/センサー） + キリル（外装/eHMI）
**ステータス:** アクティブ
**バージョン:** 1.0
**日付:** 2025年12月19日
**作成者:** パンカジ（車両ソフトウェアチーム）

---

## 目次

1. [クイックスタート](#1-クイックスタート)
2. [提供する必要があるもの](#2-提供する必要があるもの)
3. [ハードウェア-ソフトウェアインターフェース](#3-ハードウェア-ソフトウェアインターフェース)
4. [コンポーネント仕様](#4-コンポーネント仕様)
5. [組み立てガイド](#5-組み立てガイド)
6. [テスト手順](#6-テスト手順)
7. [ソフトウェアとの統合](#7-ソフトウェアとの統合)
8. [トラブルシューティング](#8-トラブルシューティング)

---

## 1. クイックスタート

### 1.1 あなたの担当範囲

**土屋（機械 + 電気 + センサー）:**
- ✅ シャーシ設計と製作
- ✅ スワーブドライブモジュール（4xステアリング + 4x駆動モーター）
- ✅ 電源システム（48Vバッテリー、DC-DCコンバーター、BMS）
- ✅ センサー設置（LiDAR、カメラ、IMU、エンコーダー、バンパー）
- ✅ コンピュートプラットフォーム設置（GMKtec Nucbox K6）
- ✅ ケーブル管理と防水処理

**キリル（外装 + eHMI）:**
- ✅ ボディパネルと外装デザイン
- ✅ eHMIハードウェア（ESP32、LED、スピーカー）
- ✅ 照明（ヘッドライト、テールライト、ターンシグナル）
- ✅ 保護カバー（LiDAR、カメラ）

**担当外:**
- ❌ 車両ソフトウェア（パンカジの責任）
- ❌ TVMサーバー（海野さんの責任）
- ❌ ソフトウェア設定（パンカジの責任）

### 1.2 パンカジが必要とするもの

**重要な成果物:**
1. **センサーデータを配信するROS 2トピック**（セクション3.2参照）
2. **モーターコマンドを受信するROS 2トピック**（セクション3.3参照）
3. **モーター制御用CANバス**（セクション3.4参照）
4. **eHMI用シリアルインターフェース**（セクション3.5参照）
5. **E-stopハードウェア回路**（セクション4.7参照）

**タイムライン:** 16週間（5週間プロトタイプ + 11週間完成）

---

## 2. 提供する必要があるもの

### 2.1 物理プラットフォーム（土屋）

**機械システム:**
- [x] 溶接アルミニウムシャーシフレーム
- [x] 4xスワーブドライブモジュール（独立ステアリング + 駆動）
- [x] サスペンションシステム（屋外の粗い地形用）
- [x] ドッキング機構（車椅子への物理的取り付け）
- [x] センサー取り付けブラケット（LiDAR、カメラ、IMU）
- [x] ケーブル配線（内部、防水）

**電気システム:**
- [x] 48V 20Ah LiFePO4バッテリー + BMS
- [x] 電源分配（48Vバス、12V・5Vへのシステム）
- [x] 4x駆動モーターコントローラー（CANバス）
- [x] 4xステアリングモーターコントローラー（PWMまたはCANバス）
- [x] コンピュートプラットフォーム（GMKtec Nucbox K6）設置
- [x] ハードウェアE-stop回路（デュアルチャネル）
- [x] 充電ポート（48V）

**センサー:**
- [x] 3D LiDAR（屋外グレードIP65+、30-100m範囲、USB/イーサネット）
- [x] 2x RGBカメラ（1920x1080、30 FPS、USB 3.0）
- [x] IMU（9-DOF: MPU-9250または同等品、I2C/SPI）
- [x] 4x駆動エンコーダー（最小360ティック/回転）
- [x] 4xステアエンコーダー（絶対値、ステアリング角度用）
- [x] 接触バンパー（前面、後面、側面 - GPIOまたはCAN）

### 2.2 外装とeHMI（キリル）

**外装:**
- [x] 防水ボディパネル（IP54+）
- [x] ヘッドライトとテールライト
- [x] ターンシグナル
- [x] LiDAR保護カバー（透明/メッシュ）
- [x] カメラ保護カバー

**eHMIハードウェア:**
- [x] ESP32-S3マイクロコントローラー
- [x] WS2812B LEDストリップ（2-3メートル、60+ LED/メートル）
- [x] I2Sオーディオアンプ（MAX98357A）
- [x] 防水スピーカー（5W+）
- [x] メインコンピュートへのシリアル接続（UART）

---

## 3. ハードウェア-ソフトウェアインターフェース

### 3.1 インターフェース文書

**重要:** 最初にこれを読んでください！
- **ファイル:** `shared/INTERFACES/HARDWARE_SOFTWARE_INTERFACE.md`
- **長さ:** 1,010行
- **ステータス:** ✅ 完成、本番対応

**これはあなたとパンカジの間の契約です。**
- パンカジとの調整なしにトピック/プロトコルを変更しないでください
- すべてのROS 2トピック名、メッセージタイプ、頻度が定義されています
- CANバスプロトコルが指定されています
- eHMI用シリアルプロトコルが指定されています

### 3.2 配信する必要があるROS 2トピック（センサーデータ）

**ハードウェアドライバーがこれらを配信する必要があります:**

```yaml
# LiDAR点群
トピック: /sensors/lidar/points
タイプ: sensor_msgs/msg/PointCloud2
頻度: 10 Hz
パブリッシャー: LiDARドライバー（あなたが提供）

# フロントカメラ画像
トピック: /sensors/camera/front/image
タイプ: sensor_msgs/msg/Image
頻度: 10 Hz
パブリッシャー: カメラドライバー（あなたが提供）

# リアカメラ画像
トピック: /sensors/camera/rear/image
タイプ: sensor_msgs/msg/Image
頻度: 10 Hz
パブリッシャー: カメラドライバー（あなたが提供）

# IMUデータ
トピック: /sensors/imu/data
タイプ: sensor_msgs/msg/Imu
頻度: 50 Hz
パブリッシャー: IMUドライバー（あなたが提供）

# バッテリーステータス
トピック: /sensors/battery/status
タイプ: sensor_msgs/msg/BatteryState
頻度: 1 Hz
パブリッシャー: CAN経由のBMSドライバー（あなたが提供）

# バンパー接触ステータス
トピック: /safety/bumpers
タイプ: std_msgs/msg/Bool（またはカスタムメッセージ）
頻度: 50 Hz
パブリッシャー: バンパーGPIOリーダー（あなたが提供）

# E-stopステータス
トピック: /safety/estop
タイプ: std_msgs/msg/Bool
頻度: 50 Hz
パブリッシャー: E-stop GPIOリーダー（あなたが提供）
```

**実装方法:**
- コンピュートプラットフォームにROS 2 Humbleをインストール
- ROS 2ドライバーノードを記述（C++またはPython）
- 起動時にドライバーを起動（systemdサービス）

**ドライバーノードの例（バンパー）:**
```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from std_msgs.msg import Bool
import RPi.GPIO as GPIO  # または適切なGPIOライブラリ

class BumperNode(Node):
    def __init__(self):
        super().__init__('bumper_node')
        self.publisher = self.create_publisher(Bool, '/safety/bumpers', 10)
        self.timer = self.create_timer(0.02, self.publish_bumper_status)  # 50Hz

        # バンパー用GPIOピンを設定
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(17, GPIO.IN, pull_up_down=GPIO.PUD_UP)  # フロントバンパー
        # ... 他のバンパーを設定

    def publish_bumper_status(self):
        msg = Bool()
        msg.data = GPIO.input(17) == GPIO.LOW  # アクティブLow
        self.publisher.publish(msg)

def main():
    rclpy.init()
    node = BumperNode()
    rclpy.spin(node)

if __name__ == '__main__':
    main()
```

### 3.3 サブスクライブする必要があるROS 2トピック（モーターコマンド）

**ハードウェアドライバーがこれらをサブスクライブする必要があります:**

```yaml
# 速度コマンド（高レベル）
トピック: /control/cmd_vel
タイプ: geometry_msgs/msg/Twist
頻度: 10 Hz（ソフトウェアから）
サブスクライバー: スワーブドライブコントローラー（あなたが提供）

# 駆動モーター速度（低レベル）
トピック: /control/swerve/drive_velocities
タイプ: std_msgs/msg/Float32MultiArray（4つの値）
頻度: 20 Hz
サブスクライバー: 駆動モーターCANコントローラー（あなたが提供）

# ステアリング角度（低レベル）
トピック: /control/swerve/steer_angles
タイプ: std_msgs/msg/Float32MultiArray（4つの値）
頻度: 20 Hz
サブスクライバー: ステアモーターPWM/CANコントローラー（あなたが提供）
```

**サブスクライバーノードの例（駆動モーター）:**
```python
#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
from std_msgs.msg import Float32MultiArray
import can  # python-canライブラリ

class DriveMotorNode(Node):
    def __init__(self):
        super().__init__('drive_motor_node')
        self.subscription = self.create_subscription(
            Float32MultiArray,
            '/control/swerve/drive_velocities',
            self.velocity_callback,
            10
        )
        # CANバスを初期化
        self.can_bus = can.interface.Bus(channel='can0', bustype='socketcan')

    def velocity_callback(self, msg):
        velocities = msg.data  # [v1, v2, v3, v4]
        for i, vel in enumerate(velocities):
            # モーターコントローラーiにCANメッセージを送信
            can_msg = can.Message(
                arbitration_id=0x100 + i,
                data=self.velocity_to_bytes(vel),
                is_extended_id=False
            )
            self.can_bus.send(can_msg)

    def velocity_to_bytes(self, vel):
        # 速度（m/s）をモーターコントローラー形式に変換
        # 例: 8ビットコントローラー用に0-255にスケール
        scaled = int((vel / 1.5) * 255)  # 最大速度1.5 m/s
        return [scaled & 0xFF]

def main():
    rclpy.init()
    node = DriveMotorNode()
    rclpy.spin(node)
```

### 3.4 CANバスプロトコル

**ネットワークトポロジー:**
```
CANバス（500 kbps）
├── 駆動モーター1（ID: 0x101）
├── 駆動モーター2（ID: 0x102）
├── 駆動モーター3（ID: 0x103）
├── 駆動モーター4（ID: 0x104）
├── ステアモーター1（ID: 0x111）
├── ステアモーター2（ID: 0x112）
├── ステアモーター3（ID: 0x113）
├── ステアモーター4（ID: 0x114）
└── BMS（ID: 0x200）
```

**メッセージフォーマット（駆動モーター）:**
```
CAN ID: 0x101-0x104
データ長: 2バイト
バイト0: 速度コマンド（符号付き、-127～+127、±1.5 m/sにスケール）
バイト1: チェックサム（オプション）
```

**メッセージフォーマット（BMS）:**
```
CAN ID: 0x200
データ長: 8バイト
バイト0-1: 電圧（uint16、mV、ビッグエンディアン）
バイト2-3: 電流（int16、mA、ビッグエンディアン）
バイト4: 充電状態（uint8、パーセンテージ0-100）
バイト5: 温度（int8、°C）
バイト6-7: 予約
```

**あなたの責任:**
- 正しいCAN IDでモーターコントローラーを設定
- モーターファームウェア/コントローラーでCANプロトコルを実装
- CANバス終端抵抗を提供（各端に120Ω）
- 標準プロトコルからの逸脱を文書化

### 3.5 シリアルプロトコル（eHMI - ESP32）

**接続:**
```
メインコンピュート（Nucbox K6）UART ←→ ESP32-S3 UART
ボーレート: 115200
データビット: 8
パリティ: なし
ストップビット: 1
```

**コマンドフォーマット（コンピュート → ESP32）:**
```json
{
  "type": "led_pattern",
  "pattern": "idle",
  "color": [0, 255, 0],
  "brightness": 128
}

{
  "type": "play_sound",
  "sound": "docking_start",
  "volume": 80
}

{
  "type": "emergency_blink",
  "enabled": true
}
```

**ステータスフォーマット（ESP32 → コンピュート）:**
```json
{
  "type": "status",
  "led_operational": true,
  "audio_operational": true,
  "cpu_temp": 45.2
}
```

**あなたの責任（キリル）:**
- NucboxとESP32間のUART接続を配線（TX/RX/GND）
- JSONコマンドを解析するESP32ファームウェアを記述
- SPI経由でWS2812B LEDを制御
- I2S経由でオーディオ再生を制御
- 5秒ごとにステータス更新を送信

**ESP32コードの例（部分）:**
```cpp
// ESP32ファームウェア（Arduino）
#include <ArduinoJson.h>
#include <FastLED.h>

#define LED_PIN 5
#define NUM_LEDS 180
CRGB leds[NUM_LEDS];

void setup() {
  Serial.begin(115200);  // NucboxへのUART
  FastLED.addLeds<WS2812B, LED_PIN, GRB>(leds, NUM_LEDS);
}

void loop() {
  if (Serial.available()) {
    String json_str = Serial.readStringUntil('\n');
    StaticJsonDocument<256> doc;
    deserializeJson(doc, json_str);

    String type = doc["type"];
    if (type == "led_pattern") {
      String pattern = doc["pattern"];
      setLEDPattern(pattern);
    } else if (type == "play_sound") {
      String sound = doc["sound"];
      playSound(sound);
    }
  }
}

void setLEDPattern(String pattern) {
  if (pattern == "idle") {
    fill_solid(leds, NUM_LEDS, CRGB::Green);
  } else if (pattern == "navigating") {
    fill_solid(leds, NUM_LEDS, CRGB::Blue);
  } else if (pattern == "docking") {
    fill_solid(leds, NUM_LEDS, CRGB::Yellow);
  } else if (pattern == "error") {
    fill_solid(leds, NUM_LEDS, CRGB::Red);
  }
  FastLED.show();
}
```

---

## 4. コンポーネント仕様

### 4.1 コンピュートプラットフォーム（GMKtec Nucbox K6）

**仕様:**
- CPU: AMD Ryzen 7 7840HS（8コア、3.8-5.1 GHz）
- RAM: 32GB DDR5
- ストレージ: 1TB NVMe SSD
- GPU: AMD Radeon 780M（統合）
- ポート: 2x USB 3.2、2x USB-C、1xイーサネット、1x HDMI

**取り付け:**
- 場所: シャーシ内部（天候から保護）
- 冷却: 十分な空気の流れを確保、ファンをブロックしない
- 振動: ゴムグロメットを使用してシャーシから分離

**電源:**
- 入力: 12V DC（DC-DCコンバーターから）
- 消費電力: 通常約65W、ピーク120W
- コネクター: DCバレルジャック（Nucbox標準）

**ソフトウェアインストール:**
- Ubuntu 22.04 LTS（パンカジがインストール）
- ROS 2 Humble（パンカジがインストール）
- 車両ソフトウェア（パンカジがインストール）

**あなたの責任:**
- シャーシ内部に確実に取り付け
- 12V電源を接続
- TVMサーバー通信用のイーサネット/WiFiを接続
- ケーブルをきれいに配線

### 4.2 3D LiDAR

**要件:**
- 範囲: 30-100メートル
- FOV: 水平360°、垂直±15°以上
- 精度: ±3cm
- 保護: IP65+（屋外グレード、防塵+防水）
- インターフェース: USB 3.0またはイーサネット

**推奨モデル:**
- Ouster OS1-64（約$3,500、イーサネット、64チャネル）
- Velodyne VLP-16（約$4,000、イーサネット、16チャネル）
- Livox Horizon（約$1,500、独自プロトコル、ロボティクスに適している）

**取り付け:**
- 場所: 車両の中央上部（360°妨げられない視界）
- 高さ: 地上約1.2m
- 安定化: 剛性マウント（ぐらつきなし）
- 保護: 防水カバー（透明またはメッシュ、キリルが提供）

**配線:**
- 電源: 12V DC（DC-DCコンバーターから）
- データ: イーサネット（CAT6）またはUSB 3.0でNucboxへ
- ケーブル長: <5メートル（信号劣化を避けるため）

**ドライバーインストール:**
- パンカジがROS 2ドライバーをインストール（例: `ouster_driver`、`velodyne_driver`）
- ドライバー設定のためにLiDARモデル/仕様をパンカジに提供

### 4.3 カメラ（2x RGB）

**要件:**
- 解像度: 1920x1080（フルHD）以上
- フレームレート: 30 FPS
- インターフェース: USB 3.0
- 保護: IP54+防水ハウジング

**推奨:**
- ELP USBカメラモジュール（USB 3.0、1080p、広角レンズ、約$100）
- Logitech C920（USB 2.0、1080p、ただし防水エンクロージャーが必要）

**取り付け:**
- フロントカメラ: 中央前方、前方/下方を向ける（ArUcoドッキング用）
- リアカメラ: 中央後方、後方を向ける（障害物認識用）
- 視野: 広角（90°+）が望ましい

**配線:**
- データ: USB 3.0でNucboxへ
- ケーブル長: <3メートル（USB 3.0長制限）

**ドライバー:**
- 標準USBビデオクラス（UVC） - ROS 2でそのまま動作
- パンカジがカメラキャリブレーションを設定

### 4.4 IMU（9-DOF）

**要件:**
- タイプ: 9-DOF（加速度計、ジャイロスコープ、磁力計）
- モデル: MPU-9250、BNO055、または同等品
- インターフェース: I2CまたはSPI
- サンプルレート: 最小50 Hz

**推奨:**
- Adafruit BNO055ブレークアウト（約$35、I2C、事前校正済み）
- SparkFun MPU-9250ブレークアウト（約$15、I2C/SPI）

**取り付け:**
- 場所: 車両シャーシの中心（質量中心付近）
- 方向: 車両フレームと軸を揃える（X=前方、Y=左、Z=上）
- 安定化: 剛性マウント（振動絶縁不要）

**配線:**
- I2C: SDA、SCL、VCC（3.3Vまたは5V）、GND
- Nucbox GPIOまたはUSB-to-I2Cアダプターに接続

**ドライバー:**
- パンカジがROS 2 IMUドライバーを使用（例: `imu_tools`、`bno055_driver`）
- IMUモデル/I2Cアドレスを提供

### 4.5 エンコーダー

**駆動エンコーダー（4x）:**
- タイプ: インクリメンタルまたは絶対値
- 解像度: 最小360ティック/回転
- インターフェース: ホール効果センサー（3線: VCC、GND、信号）
- 取り付け: 駆動モーターシャフトまたはホイールハブ

**ステアエンコーダー（4x）:**
- タイプ: 絶対値（ステアリング角度フィードバックに必要）
- 解像度: 10ビット（1024位置）以上
- インターフェース: アナログ（0-5V）、I2C、またはSPI
- 取り付け: ステアリング軸

**あなたの責任:**
- 各モーター/軸にエンコーダーをインストール
- モーターコントローラーまたはNucbox GPIOに直接配線
- エンコーダー仕様（PPR、インターフェース）をパンカジに提供

### 4.6 バンパー

**要件:**
- タイプ: 接触スイッチまたは圧力センサー
- 場所: 前面、後面、左側、右側（最小4つ）
- インターフェース: GPIO（デジタル入力、アクティブLow推奨）

**推奨:**
- 機械式マイクロスイッチ（防水、IP65+）
- フレキシブルバンパーストリップに取り付け

**配線:**
- Nucbox GPIOピンに接続
- プルアップ抵抗を使用（10kΩ内部プルアップ可）
- アクティブLow: 押下 = LOW（0V）、解放 = HIGH（3.3V/5V）

**配線例:**
```
バンパースイッチ ──┬── GND
                  └── GPIOピン（3.3Vにプルアップ）
```

### 4.7 緊急停止（E-stop）

**重要な安全要件:**

**ハードウェア回路:**
```
バッテリー48V ──┬── E-stopボタン（デュアルチャネル） ──┬── モーターコントローラー電源
                │                                     │
                └── （常時閉接点）                    └── ソフトウェアモニター（GPIO）
```

**要件:**
- デュアルチャネル緊急停止ボタン（Eaton/Pilz/Schneider）
- 常時閉（NC）接点（押されたときに回路を遮断）
- モーターコントローラー電源にハードワイヤード（ソフトウェアでオーバーライド不可）
- 冗長監視: ハードウェアとソフトウェア

**E-stopボタン仕様:**
- タイプ: マッシュルームヘッド、赤、ツイストリリース
- 保護: IP65+（防水）
- 取り付け: 簡単にアクセス可能（車両の上部または側面）

**ソフトウェアモニター:**
- E-stopステータスをNucbox GPIOに接続
- `/safety/estop`トピックを配信（Bool、50 Hz）
- パンカジの安全モニターがこのトピックを読み取る

**テスト:**
- E-stopを押す → すべてのモーターが100ms以内に停止
- ソフトウェアがE-stop信号を受信
- E-stopが解除されるまで車両は移動できない

---

## 5. 組み立てガイド

### 5.1 組み立て順序（推奨）

**フェーズ1: 機械フレーム（1-2週目）**
1. シャーシフレームを製作（溶接アルミニウム）
2. スワーブドライブモジュールを設置（4x、角に）
3. サスペンションシステムを取り付け
4. ドッキング機構を設置（前面/後面）

**フェーズ2: 電源システム（3週目）**
5. バッテリー（48V 20Ah LiFePO4）を保護区画に設置
6. BMS（バッテリーに接続）を設置
7. DC-DCコンバーター（48V→12V、48V→5V）を設置
8. 電源分配を配線（48Vバス、12Vバス、5Vバス）
9. E-stop回路を設置（モーター電源にハードワイヤード）
10. 充電ポートを設置

**フェーズ3: コンピュートとセンサー（4-5週目）**
11. Nucbox K6をシャーシ内部に取り付け
12. Nucboxに12V電源を接続
13. LiDARを上部（中央）に取り付け
14. カメラを取り付け（前面+後面）
15. IMU（シャーシ中央）を設置
16. エンコーダー（駆動+ステア）を設置
17. バンパー（周囲）を設置

**フェーズ4: モーター制御（6-8週目）**
18. 駆動モーターコントローラー（4x、CANバス）を設置
19. ステアモーターコントローラー（4x、PWMまたはCAN）を設置
20. CANバスを配線（ツイストペア、両端に120Ω終端）
21. モーターをコントローラーに接続
22. モーターを個別にテスト（CANツールまたはROSで）

**フェーズ5: eHMI（9-10週目、キリル）**
23. ESP32-S3をシャーシ内部に設置
24. LEDストリップ（WS2812B）を周囲に配線
25. スピーカー（防水）を設置
26. オーディオアンプ（I2S）を接続
27. ESP32からNucboxへUARTを配線
28. ESP32に5V電源を接続

**フェーズ6: ケーブル管理（11週目）**
29. すべてのケーブルを内部配線（外部にぶら下げない）
30. ケーブルタイとマウントを使用
31. すべてのコネクターにラベルを付ける
32. すべての外部コネクターを防水処理（IP54+）

**フェーズ7: 外装（12-16週目、キリル）**
33. ボディパネルを製作
34. ヘッドライトとテールライトを設置
35. 保護カバーを設置（LiDAR、カメラ）
36. ブランディング/ロゴを適用
37. 最終防水チェック

### 5.2 電源分配図

```
48Vバッテリー（20Ah LiFePO4）
    │
    ├──[BMS]──[E-stop]──┬── 駆動モーターコントローラー（4x） ─── 駆動モーター（4x）
    │                   │
    │                   └── ステアモーターコントローラー（4x） ─── ステアモーター（4x）
    │
    ├──[DC-DC 48V→12V、20A]──┬── Nucbox K6（コンピュート）
    │                        ├── LiDAR
    │                        ├── カメラ（2x）
    │                        └── モーターコントローラー（ロジック電源）
    │
    └──[DC-DC 48V→5V、10A]───┬── ESP32-S3
                             ├── IMU
                             ├── エンコーダー
                             └── バンパー
```

### 5.3 CANバス配線

```
Nucbox K6（CANインターフェース）
    │
    ├── CAN_H（ツイストペア、黄色）
    ├── CAN_L（ツイストペア、緑）
    │
    ├─[120Ω終端]
    │
    ├── モーター1（ID: 0x101）
    ├── モーター2（ID: 0x102）
    ├── モーター3（ID: 0x103）
    ├── モーター4（ID: 0x104）
    ├── ステア1（ID: 0x111）
    ├── ステア2（ID: 0x112）
    ├── ステア3（ID: 0x113）
    ├── ステア4（ID: 0x114）
    ├── BMS（ID: 0x200）
    │
    └─[120Ω終端]
```

**配線のヒント:**
- CAN_HとCAN_Lにツイストペアケーブルを使用
- ケーブル長を合計<40メートルに保つ
- バスの両端に120Ω終端抵抗
- 300mm以上のスタブ（T接続）を避ける

---

## 6. テスト手順

### 6.1 電源システムテスト

**テスト1: バッテリー電圧**
```
手順:
1. すべての負荷を切断
2. マルチメーターでバッテリー電圧を測定
期待値: 48V ±2V（LiFePO4の場合、満充電51.2V、空40V）
```

**テスト2: DC-DCコンバーター**
```
手順:
1. 負荷（Nucbox、LiDAR）を接続
2. 出力電圧を測定
期待値: 12V ±0.5V、5V ±0.25V
```

**テスト3: E-stop**
```
手順:
1. システム電源ON
2. E-stopボタンを押す
期待値: すべてのモーター電源が100ms以内に切断される
         E-stop GPIOがLOWを読み取る
```

### 6.2 センサーテスト

**テスト1: LiDAR**
```bash
# Nucboxで（パンカジがドライバーをインストール後）
ros2 topic echo /sensors/lidar/points

# 期待値: 約10Hzで点群データがストリーミング
# データなしの場合: 電源（12V）、イーサネット接続、ドライバー設定を確認
```

**テスト2: カメラ**
```bash
ros2 topic echo /sensors/camera/front/image --no-arr

# 期待値: 30Hzで画像メッセージ
# データなしの場合: USB接続、カメラ電源を確認
```

**テスト3: IMU**
```bash
ros2 topic echo /sensors/imu/data

# 期待値: 50HzでIMUデータ、姿勢クォータニオン、角速度
# データなしの場合: I2C接続、I2Cアドレス、ドライバー設定を確認
```

**テスト4: バンパー**
```bash
ros2 topic echo /safety/bumpers

# 各バンパーを押す → 値がTrueに変わるはず
# 期待値: 20ms以内に応答
```

### 6.3 モーター制御テスト

**テスト1: CANバス通信**
```bash
# Nucboxにcan-utilsをインストール
sudo apt install can-utils

# CANインターフェースを起動
sudo ip link set can0 type can bitrate 500000
sudo ip link set can0 up

# メッセージをリッスン
candump can0

# 期待値: BMSメッセージ（ID 0x200）がブロードキャスト
```

**テスト2: 駆動モーター**
```bash
# CAN経由でテストコマンドを送信
cansend can0 101#7F  # モーター1、50%前進（127十進数 = 0x7F）

# 期待値: モーター1が半速で前進回転
# モーター2、3、4（ID 102、103、104）について繰り返す
```

**テスト3: ステアリングモーター**
```
# PWMまたはCAN経由（セットアップによる）
# 各モーターにステアリングコマンドを送信
# 期待値: ホイールがコマンド角度に回転
```

### 6.4 eHMIテスト（キリル）

**テスト1: シリアル通信**
```bash
# Nucboxで
screen /dev/ttyUSB0 115200  # または/dev/ttyACM0

# テストコマンドを送信
{"type":"led_pattern","pattern":"idle","color":[0,255,0],"brightness":128}

# 期待値: ESP32がコマンドを受信、LEDが緑に変わる
```

**テスト2: LED制御**
```
# パターンを循環: idle、navigating、docking、error
# 期待値: LEDが適切に色を変える
```

**テスト3: オーディオ**
```
# サウンドコマンドを送信
{"type":"play_sound","sound":"startup","volume":80}

# 期待値: スピーカーが起動音を再生
```

---

## 7. ソフトウェアとの統合

### 7.1 パンカジへの引き渡し

**パンカジが開始する前に:**
- [x] すべてのハードウェアが組み立て済み
- [x] 電源システムがテスト済みで動作可能
- [x] すべてのセンサーが取り付けられ、電源供給済み
- [x] NucboxにUbuntu 22.04がインストール済み（またはパンカジがインストール）
- [x] ネットワーク構成（WiFiまたはイーサネット）が動作

**パンカジに提供するもの:**
1. **ハードウェア仕様書:**
   - LiDARモデルと接続タイプ（USB/イーサネット）
   - カメラモデルとUSBポート
   - IMUモデルとI2Cアドレス
   - エンコーダー仕様（PPR、インターフェース）
   - CANバスボーレートとデバイスID
   - ESP32シリアルポート（/dev/ttyUSB0または/dev/ttyACM0）

2. **配線図:**
   - どのUSBポートがLiDAR
   - どのUSBポートがカメラ（前面/後面）
   - CANインターフェースデバイス名（can0）
   - GPIOピン割り当て（バンパー、E-stop）

3. **テスト結果:**
   - 電源システム電圧が確認済み
   - すべてのセンサーが個別にテスト済み
   - モーター制御がテスト済み
   - E-stopがテスト済み

**パンカジが行うこと:**
- ROS 2 Humbleをインストール
- センサードライバー（LiDAR、カメラ、IMU）をインストール
- モーター制御ノード（CANバス）を記述
- eHMIノード（ESP32へのシリアル）を記述
- 指定されたROS 2トピックを設定
- ハードウェアとの統合をテスト

### 7.2 共同テスト（12-15週目）

**テスト1: センサーデータパイプライン**
- パンカジがすべてのセンサートピックが正しく配信されていることを確認
- 必要に応じてドライバー設定を調整
- カメラをキャリブレート（内部/外部）

**テスト2: モーター制御**
- パンカジがROSトピック経由でテストコマンドを送信
- モーターが正しく応答することを確認
- 必要に応じてPIDコントローラーを調整

**テスト3: 安全システム**
- E-stopをテスト（ハードウェアとソフトウェア）
- バンパーがソフトウェア応答をトリガーすることをテスト
- バッテリー監視を確認

**テスト4: eHMI**
- パンカジがLED/サウンドコマンドを送信
- ESP32が受信して実行することを確認
- すべてのLEDパターンとサウンドをテスト

### 7.3 トラブルシューティングチェックリスト

**問題: LiDARがデータを配信していない**
```
あなたの確認:
- LiDARに電源が供給されているか?（12V電源）
- イーサネット/USBケーブルが接続されているか?
- LiDAR LEDが点滅しているか（動作を示す）?

パンカジの確認:
- ドライバーがインストールされ、実行されているか?
- 正しいトピック名が設定されているか?
- ネットワーク設定（イーサネットLiDARの場合）?
```

**問題: モーターがコマンドに応答しない**
```
あなたの確認:
- CANバスに電源が供給されているか?
- 終端抵抗がインストールされているか（両端に120Ω）?
- モーターコントローラーが正しいIDで設定されているか?
- `candump`でCANメッセージが見えるか?

パンカジの確認:
- ROSノードがコマンドを送信しているか?
- 正しいCANメッセージフォーマット?
- コード内の正しいモーターID?
```

**問題: E-stopがモーターを停止しない**
```
あなたの確認:
- E-stopが正しく配線されているか（常時閉）?
- E-stopを押すとモーター電源が切断されるか?
- E-stop GPIOが接続されているか?

重要: これは安全上の問題、直ちに修正する必要がある！
```

---

## 8. 成果物チェックリスト

### 8.1 5週目の成果物（プロトタイプ）

- [ ] シャーシフレームが組み立て済み
- [ ] スワーブドライブモジュールが設置済み（基本動作のみ）
- [ ] 電源システムが動作可能（バッテリー、DC-DC、BMS）
- [ ] Nucbox K6が取り付けられ、電源供給済み
- [ ] LiDARが取り付けられ、データを配信（`ros2 topic echo`でテスト）
- [ ] カメラが取り付けられ、ストリーミング中（`ros2 topic echo`でテスト）
- [ ] E-stop回路が動作
- [ ] 文書: 配線図、センサー仕様

**マイルストーン:** 「ウォーキングスケルトン」 - プラットフォームが駆動可能、センサーが配信

### 8.2 16週目の成果物（完全プラットフォーム）

- [ ] すべての4つのスワーブモジュールが完全に動作可能（ステアリング+駆動）
- [ ] すべてのセンサーが設置およびテスト済み（LiDAR、カメラ、IMU、エンコーダー、バンパー）
- [ ] 充電ポート付きの最終化された電源システム
- [ ] ドッキング機構が設置済み
- [ ] eHMIが完成（ESP32、LED、スピーカー）
- [ ] 外装パネルと保護カバー（IP54+）
- [ ] すべてのケーブル管理が完了（防水コネクター）
- [ ] 安全システムが検証済み（E-stop <100ms応答）
- [ ] パンカジとの統合テストが完了
- [ ] 最終文書パッケージが納品

**マイルストーン:** パンカジのソフトウェアでのフィールドテストの準備完了

---

## 9. まとめ

**パンカジへの成果物:**
1. ✅ 物理プラットフォーム（シャーシ、モーター、電源、センサー）
2. ✅ センサーデータを配信するROS 2トピック（7トピック）
3. ✅ モーターコマンドをサブスクライブするROS 2トピック（3トピック）
4. ✅ モーター制御用CANバス
5. ✅ eHMI用シリアルインターフェース（ESP32）
6. ✅ E-stopハードウェア回路
7. ✅ ハードウェア仕様書と配線図
8. ✅ テスト結果文書

**タイムライン:**
- 5週目: プロトタイプ（基本動作+センサー）
- 16週目: 完全プラットフォーム（すべての機能）
- 12-15週目: パンカジとの共同テスト

**重要な成功要因:**
- HARDWARE_SOFTWARE_INTERFACE.mdに正確に従う
- 統合前に各コンポーネントを個別にテスト
- インターフェース変更についてパンカジと調整
- 安全性を優先（E-stop、バンパー、バッテリー保護）

**次のステップ:**
1. このガイドをチームと一緒にレビュー
2. HARDWARE_SOFTWARE_INTERFACE.mdをレビュー
3. コンポーネントを注文（LiDAR、カメラ、IMU、モーター）
4. シャーシ製作を開始
5. パンカジとの週次同期ミーティングを設定

---

**文書ステータス:** ✅ 完成
**バージョン:** 1.0
**日付:** 2025年12月19日
**作成者:** パンカジ

**組み立て頑張ってください！ 🔧**
