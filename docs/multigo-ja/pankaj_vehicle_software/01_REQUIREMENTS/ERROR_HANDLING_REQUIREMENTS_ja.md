# エラー処理要件

**プロジェクト:** 屋外車椅子搬送ロボット - マルチチームシステム
**文書タイプ:** 要件仕様
**ステータス:** アクティブ
**バージョン:** 1.0
**最終更新:** 2025-12-17
**オーナー:** 統合チーム（全チーム）

---

## 目次

1. [はじめに](#1-はじめに)
2. [エラー処理原則](#2-エラー処理原則)
3. [エラーカテゴリと分類](#3-エラーカテゴリと分類)
4. [エラー検出](#4-エラー検出)
5. [エラー報告とロギング](#5-エラー報告とロギング)
6. [エラーリカバリー戦略](#6-エラーリカバリー戦略)
7. [優雅な劣化](#7-優雅な劣化)
8. [車両エラー処理](#8-車両エラー処理)
9. [TVMサーバーエラー処理](#9-tvmサーバーエラー処理)
10. [ネットワークエラー処理](#10-ネットワークエラー処理)
11. [データベースエラー処理](#11-データベースエラー処理)
12. [ユーザー向けエラーメッセージ](#12-ユーザー向けエラーメッセージ)
13. [安全性重要エラー処理](#13-安全性重要エラー処理)
14. [エラー伝播と境界](#14-エラー伝播と境界)
15. [タイムアウト処理](#15-タイムアウト処理)
16. [リソース枯渇処理](#16-リソース枯渇処理)
17. [エラーシナリオのテスト](#17-エラーシナリオのテスト)

---

## 1. はじめに

### 1.1 目的

この文書は、屋外車椅子搬送ロボットフリートシステムのエラー処理要件を規定します。堅牢なエラー処理は以下を保証します:
- **安全性:** 車両は安全に故障（乗客への危害なし）
- **信頼性:** システムは一時的エラーから自動的にリカバリー
- **使いやすさ:** ユーザーは明確で実用的なエラーメッセージを受信
- **保守性:** 開発者はエラーを迅速に診断して修正可能

### 1.2 範囲

エラー処理要件は以下に適用されます:
- **チーム1（パンカジ）:** 車両ソフトウェア（ROS 2、センサー、ナビゲーション）
- **チーム2（海野）:** TVMサーバー（API、データベース、フリートロジック）
- **チーム3（前田さん）:** ハードウェア（センサー、モーター、計算ユニット）

### 1.3 定義

**エラー:** 期待される動作からの逸脱（例: センサー故障、ネットワークタイムアウト）
**例外:** 通常のプログラムフローを中断するエラー（例: `NullPointerException`）
**故障:** エラーを引き起こす根本的欠陥（例: ソフトウェアバグ、ハードウェア欠陥）
**障害:** 必要な機能を実行できない完全な不能（例: 車両がナビゲートできない）

**エラー重要度:**
- **重要:** 安全リスク、即座の行動が必要（例: 障害物検出故障）
- **高:** 機能障害、ユーザーがタスクを完了できない（例: ログイン失敗）
- **中:** 機能低下、回避策が存在（例: 遅いAPI応答）
- **低:** 軽微な不便、コア機能への影響なし（例: ログローテーション遅延）

---

## 2. エラー処理原則

### REQ-ERR-001 [重要]
**フェイルセーフ原則**
- システムは重要なエラー時に安全な状態をデフォルトとしなければならない
- 例: 障害物検出が失敗した場合 → 車両を即座に停止
- データがない場合に「最良のケース」を仮定しない

**根拠:** 安全性重要システム（ISO 13849）

### REQ-ERR-002 [重要]
**フェイルファスト原則**
- システムはできるだけ早くエラーを検出しなければならない
- 無効な状態を伝播させない（入力を即座に検証）
- 例: API境界で無効なミッション座標を拒否（ナビゲーション層ではない）

**根拠:** カスケード障害防止

### REQ-ERR-003 [重要]
**サイレント障害なし**
- エラーは決してサイレントに無視してはならない（空の`catch`ブロックなし）
- 全エラーはログされるか報告されなければならない
- 例: センサー読み取りが失敗した場合、エラーをログしてフォールバック動作をトリガー

**根拠:** デバッグ可能性、説明責任

### REQ-ERR-004 [高]
**エラー分離**
- 1つのコンポーネントのエラーはシステム全体をクラッシュさせてはならない
- バルクヘッドを使用: 障害を分離（例: 車両Aの故障が他の車両に影響しない）
- 例: 車両AのLiDARが故障しても、他の車両は動作継続

**根拠:** 耐障害性、可用性

### REQ-ERR-005 [高]
**優雅な劣化**
- システムは非重要エラー時に優雅に劣化しなければならない
- 完全な障害ではなく部分的機能を維持
- 例: カメラが故障した場合、LiDARのみを使用してナビゲーション継続

**根拠:** 可用性、ユーザーエクスペリエンス

### REQ-ERR-006 [高]
**指数バックオフでの再試行**
- 一時的エラー（ネットワーク、一時的にリソース利用不可）は再試行しなければならない
- 指数バックオフを使用: 1秒、2秒、4秒、8秒、...（雷の群れ防止）
- 最大再試行回数: 設定可能（デフォルト5）

**根拠:** 一時的障害への耐性

### REQ-ERR-007 [中]
**ユーザーフレンドリーなエラーメッセージ**
- エンドユーザーへのエラーメッセージは明確で実用的、非技術的でなければならない
- 例: 「ミッションを作成できません。ピックアップ場所を確認してください。」（「NullPointerException at line 42」ではない）
- 含む: 何が起こったか、なぜか、ユーザーが何をできるか

**根拠:** 使いやすさ

### REQ-ERR-008 [中]
**エラーコンテキスト保存**
- エラーログはコンテキストを含まなければならない: タイムスタンプ、ユーザーID、車両ID、リクエストID、スタックトレース
- エラーを再現するのに十分な情報
- 例: 「ミッション作成失敗 | ユーザー: 123 | 車両: V5 | ピックアップ: (lat, lon) | エラー: 無効な座標」

**根拠:** デバッグ可能性

---

## 3. エラーカテゴリと分類

### 3.1 エラー分類法

### REQ-ERR-009 [高]
**エラーカテゴリ**
- システムはエラーをカテゴリに分類しなければならない:
  1. **ハードウェアエラー:** センサー故障、モーター誤動作、電源喪失
  2. **ソフトウェアエラー:** ヌルポインター、メモリ不足、セグメンテーション違反
  3. **ネットワークエラー:** 接続タイムアウト、DNS障害、パケット損失
  4. **データエラー:** 無効な入力、破損データ、制約違反
  5. **外部エラー:** サードパーティAPI障害、GPS利用不可
  6. **ユーザーエラー:** 無効なリクエスト、不正アクセス
  7. **設定エラー:** 設定不足、無効な値

**目的:** カテゴリ毎のターゲットリカバリー戦略

### 3.2 エラーコード

### REQ-ERR-010 [高]
**標準化エラーコード**
- 全エラーはユニークなエラーコード（英数字）を持たなければならない
- 形式: `<SYSTEM>-<CATEGORY>-<NUMBER>`
  - 例: `VEH-NAV-001`（車両ナビゲーションエラー001）
  - 例: `TVM-DB-042`（TVMデータベースエラー042）
- エラーコードレジストリは文書で維持

**目的:** 簡単なエラー検索、サポート、分析

**エラーコード範囲:**
- `VEH-*`: 車両エラー（1000-1999）
- `TVM-*`: TVMサーバーエラー（2000-2999）
- `API-*`: APIエラー（3000-3999）
- `DB-*`: データベースエラー（4000-4999）
- `NET-*`: ネットワークエラー（5000-5999）

### REQ-ERR-011 [中]
**HTTPステータスコード（API）**
- APIエラーは適切なHTTPステータスコードを使用しなければならない:
  - **400 Bad Request:** 無効な入力（ユーザーエラー）
  - **401 Unauthorized:** 認証が必要
  - **403 Forbidden:** 権限不足
  - **404 Not Found:** リソースが存在しない
  - **409 Conflict:** リソース競合（例: ミッション重複）
  - **429 Too Many Requests:** レート制限超過
  - **500 Internal Server Error:** サーバーエラー（未処理例外）
  - **503 Service Unavailable:** 一時的停止（メンテナンス、過負荷）

**根拠:** REST API標準（RFC 7231）

---

## 4. エラー検出

### 4.1 入力検証

### REQ-ERR-012 [重要]
**全入力を検証**
- システムはエントリーポイントで全外部入力を検証しなければならない
- 検証: タイプ、範囲、形式、長さ
- 例: ミッションピックアップ座標は施設境界内でなければならない
- 無効な入力を即座に拒否（フェイルファスト）

**根拠:** ガベージイン、ガベージアウトを防止

### REQ-ERR-013 [高]
**API入力検証**
- APIは処理前に全リクエストパラメータを検証しなければならない
- スキーマ検証を使用（例: JSON Schema、OpenAPI仕様）
- 詳細な検証エラー付きで400 Bad Requestを返す

**例:**
```json
{
  "error": "検証失敗",
  "code": "API-VAL-001",
  "details": [
    {"field": "pickup_location", "error": "必須フィールド不足"},
    {"field": "resident_id", "error": "無効なUUID形式"}
  ]
}
```

### REQ-ERR-014 [高]
**データベース制約検証**
- データベースは制約を適用しなければならない（外部キー、ユニーク、not null）
- アプリケーションは制約違反をキャッチしてユーザーフレンドリーなエラーを返す
- 例: 外部キー違反（resident_idが存在しない）の場合、「入居者が見つかりません」を返す

**根拠:** データ整合性

### 4.2 ヘルスチェック

### REQ-ERR-015 [重要]
**コンポーネントヘルスチェック**
- 全重要コンポーネントはヘルスチェックエンドポイントを実装しなければならない
- ヘルスチェックは返す: Healthy、Degraded、Unhealthy
- 例: 車両ヘルスチェックは検証: LiDAR、カメラ、モーター、バッテリー

**TVMサーバーヘルスチェック:**
```http
GET /health
応答:
{
  "status": "healthy",
  "components": {
    "database": "healthy",
    "redis": "healthy",
    "vehicle_connection": "healthy"
  },
  "timestamp": "2025-12-17T10:30:00Z"
}
```

### REQ-ERR-016 [高]
**定期的ヘルス監視**
- ヘルスチェックは定期的に実行しなければならない（30秒毎）
- ヘルスチェックが3回連続で失敗した場合、アラートをトリガー
- アラート: オンコールエンジニアへのPagerDutyページ

**根拠:** プロアクティブなエラー検出

### REQ-ERR-017 [高]
**ウォッチドッグタイマー**
- 安全性重要コンポーネント（ナビゲーション、障害物検出）はウォッチドッグタイマーを持たなければならない
- コンポーネントがタイムアウト内（例: 5秒）にハートビートを送信しない場合、故障を仮定
- アクション: フェイルセーフをトリガー（例: 車両停止）

**根拠:** ハングプロセス検出（ISO 13849）

---

## 5. エラー報告とロギング

### 5.1 ロギング要件

### REQ-ERR-018 [重要]
**全エラーをログ**
- 全エラーは最小重要度レベルでログしなければならない: WARNING
- 重要なエラーはERRORまたはCRITICALレベルでログ
- ログに含む: タイムスタンプ、重要度、エラーコード、メッセージ、コンテキスト（ユーザー、車両、リクエストID）

**ログ形式（JSON）:**
```json
{
  "timestamp": "2025-12-17T10:30:00Z",
  "level": "ERROR",
  "error_code": "VEH-NAV-001",
  "message": "パスプランニング失敗: 有効なパスが見つかりません",
  "context": {
    "vehicle_id": "V123",
    "mission_id": "M456",
    "pickup": {"lat": 35.6, "lon": 139.7},
    "dropoff": {"lat": 35.61, "lon": 139.71}
  },
  "stack_trace": "..."
}
```

### REQ-ERR-019 [高]
**構造化ロギング**
- ログは構造化形式（JSON、プレーンテキストではない）を使用しなければならない
- 可能にする: SIEM（Elasticsearch）での解析、フィルタリング、集約
- 含む: 相関ID（サービス間でリクエストをトレース）

**根拠:** 可観測性、デバッグ可能性

### REQ-ERR-020 [高]
**ログ保持**
- エラーログは最低90日間保持しなければならない
- 重要なエラー: 1年間保持
- ログは集中ログ集約システム（ELKスタック）に保存

**根拠:** インシデント調査、コンプライアンス

### REQ-ERR-021 [高]
**ログ内のPII削除**
- ログは個人識別情報（PII）を含んではならない
- 削除: 入居者名、メール、医療情報
- 名前の代わりに入居者IDを使用
- PRIVACY_REQUIREMENTS.md REQ-PRIV-056参照

**根拠:** GDPR準拠

### 5.2 エラーメトリクス

### REQ-ERR-022 [高]
**エラー率追跡**
- システムはコンポーネント毎のエラー率（毎分エラー数）を追跡しなければならない
- Prometheusメトリクスとして公開: `error_count{component="vehicle_nav", severity="critical"}`
- エラー率が閾値を超えた場合にアラート（例: >10/分）

**根拠:** プロアクティブな監視

### REQ-ERR-023 [中]
**エラー分布ダッシュボード**
- システムはエラーダッシュボード（Grafana）を提供すべき
- 可視化: タイプ別エラー数、時間経過のエラー率、トップエラー
- 目的: システム的問題の特定

**根拠:** 運用可視性

---

## 6. エラーリカバリー戦略

### 6.1 自動リカバリー

### REQ-ERR-024 [重要]
**一時的エラーの自動再試行**
- 一時的エラーは自動的に再試行しなければならない
- 一時的エラーの例: ネットワークタイムアウト、一時的にリソース利用不可、レート制限
- 再試行ロジック: 指数バックオフ（1秒、2秒、4秒、8秒、16秒）
- 最大再試行: 5（設定可能）

**根拠:** 耐性

### REQ-ERR-025 [重要]
**サーキットブレーカーパターン**
- 外部依存関係（TVM API、GPSサービス）にサーキットブレーカーを実装
- 状態: Closed（通常）、Open（障害中）、Half-Open（リカバリーテスト中）
- 依存関係が繰り返し失敗した場合（例: 60秒で5回失敗）、サーキットをオープン（呼び出し停止）
- タイムアウト後（例: 30秒）、half-openに入る（リカバリーをテスト）

**根拠:** カスケード障害防止、高速障害

**サーキットブレーカーステートマシン:**
```
Closed ──[5回失敗]──> Open ──[30秒タイムアウト]──> Half-Open
   ↑                                                  │
   └──────────[成功]─────────────────────────────────┘
                                            │
                                       [失敗]
                                            ↓
                                          Open
```

### REQ-ERR-026 [高]
**フォールバック動作**
- 重要なコンポーネントはエラー時にフォールバック動作を持たなければならない
- 例: GPS利用不可の場合 → デッドレコニング（オドメトリ）を使用
- 例: TVM到達不可の場合 → ミッションを車両でローカルにキュー

**根拠:** 可用性

### REQ-ERR-027 [高]
**自己修復**
- システムはリカバリー可能なエラーで自己修復を試みるべき
- 例: ROSノードがクラッシュした場合 → ノードを自動的に再起動（スーパーバイザープロセス）
- 例: データベース接続が失われた場合 → 自動的に再接続

**根拠:** 手動介入を削減

### 6.2 手動リカバリー

### REQ-ERR-028 [高]
**管理者リカバリーアクション**
- システムは手動リカバリー用の管理ツールを提供しなければならない:
  - サービス再起動（APIまたはダッシュボード経由）
  - キャッシュクリア（Redisフラッシュ）
  - 失敗したミッションを再試行
  - 車両を「メンテナンスモード」としてマーク

**根拠:** オペレーター制御

### REQ-ERR-029 [中]
**リカバリーランブック**
- 一般的なエラーは文書化されたリカバリーランブックを持たなければならない
- ランブックには含む: 症状、診断手順、リカバリー手順
- Wikiまたはインシデント対応文書に保存

**ランブック例:** 「車両が'ナビゲート中'状態でスタック」
1. 症状: 車両が動かない、ステータスが「ナビゲート中」を表示
2. 診断: ナビゲーションエラーのログを確認、センサーヘルスを確認
3. リカバリー: 「ミッション中止」コマンドを送信、次に車両ナビゲーションノードを再起動

---

## 7. 優雅な劣化

### REQ-ERR-030 [重要]
**機能削減で動作継続**
- 非重要エラー時、システムは機能削減で動作継続しなければならない
- 劣化状態をユーザーに通知
- 例: カメラが故障した場合、LiDARのみを使用してナビゲーション継続（警告表示）

**根拠:** 可用性

### REQ-ERR-031 [高]
**センサー冗長性**
- 車両は1つのセンサーが故障してもナビゲーション継続しなければならない（最小限のセンサーが利用可能な限り）
- ナビゲーション用最小センサー: LiDAR（プライマリ）、IMU（方向のバックアップ）
- LiDARとカメラの両方が故障した場合 → ナビゲートできない、基地に帰還

**根拠:** 耐障害性

### REQ-ERR-032 [高]
**API部分応答**
- APIクエリが部分結果を返す場合（例: 3つのデータベースシャードのうち1つがダウン）、部分データを返す
- 応答に警告を含む: `"warning": "部分結果: 1データソース利用不可"`
- 完全な障害より良い

**根拠:** 可用性

### REQ-ERR-033 [中]
**フォールバックとしてのキャッシュデータ**
- リアルタイムデータが利用不可の場合、システムはキャッシュデータを使用してもよい（許容可能な古さの場合）
- 例: 車両テレメトリストリームがダウンの場合、ダッシュボードは最後の既知状態を表示（タイムスタンプ付き）
- 表示: 「最終更新: 2分前（リアルタイム利用不可）」

**根拠:** ユーザーエクスペリエンス

---

## 8. 車両エラー処理

### 8.1 ナビゲーションエラー

### REQ-ERR-034 [重要]
**パスプランニング失敗**
- パスプランナーが有効なパスを見つけられない場合（例: ゴール到達不可）、以下を行う:
  1. エラーをログ: `VEH-NAV-001`
  2. ミッション中止
  3. TVMサーバーに通知: 「ミッション失敗: ゴール到達不可」
  4. ホーム位置に帰還（安全駐車エリア）

**根拠:** 安全性、ユーザー通知

### REQ-ERR-035 [重要]
**障害物検出失敗**
- 障害物検出が失敗した場合（LiDARエラー、カメラエラー）、以下を行う:
  1. **車両を即座に停止**（緊急停止）
  2. エラーをログ: `VEH-OBS-001`（重要）
  3. 車両に警告を表示: 「障害物検出故障。手動制御のみ。」
  4. TVMサーバーに通知: 「車両V123がセーフモード: 障害物検出失敗」
  5. センサー修理まで自律モードを無効化

**根拠:** 安全性重要（ISO 13849）

### REQ-ERR-036 [高]
**ローカライゼーション失敗**
- ローカライゼーションが失敗した場合（車両位置を特定できない）、以下を行う:
  1. 車両を停止（または0.2 m/sに減速）
  2. 再ローカライゼーション試行（環境をスキャン、マップとマッチ）
  3. 30秒以内に再ローカライゼーション成功 → ミッション再開
  4. 再ローカライゼーション失敗 → ミッション中止、手動回収を要求

**根拠:** 位置なしではナビゲートできない

### REQ-ERR-037 [高]
**スタック検出**
- 車両はスタックを検出しなければならない（例: 車輪が空転、10秒間移動なし）
- リカバリー試行:
  1. 0.5メートル後退
  2. パスを再プラン（スタックエリアを回避）
  3. 3回試行後もスタックの場合 → ミッション中止、支援を要求

**根拠:** 自律リカバリー

### 8.2 センサーエラー

### REQ-ERR-038 [重要]
**LiDAR故障**
- LiDARが故障した場合（5秒超データなし）、以下を行う:
  1. エラーをログ: `VEH-LID-001`（重要）
  2. カメラのみナビゲーションに切り替え（利用可能な場合）
  3. 最大速度を0.5 m/sに削減（限定的センシング）
  4. TVMに通知: 「LiDAR故障、劣化モード」

**根拠:** ナビゲーション用プライマリセンサー

### REQ-ERR-039 [高]
**カメラ故障**
- カメラが故障した場合、以下を行う:
  1. エラーをログ: `VEH-CAM-001`（高）
  2. LiDARのみでナビゲーション継続
  3. ビジュアルドッキングを無効化（カメラが必要）
  4. TVMに通知: 「カメラ故障、ビジュアル機能無効化」

**根拠:** セカンダリセンサー、劣化可能

### REQ-ERR-040 [高]
**IMU故障**
- IMUが故障した場合（方向データなし）、以下を行う:
  1. エラーをログ: `VEH-IMU-001`（高）
  2. 車輪オドメトリから方向を推定（精度低下）
  3. 最大速度を0.5 m/sに削減（方向精度限定）
  4. TVMに通知: 「IMU故障、劣化ローカライゼーション」

**根拠:** IMUはローカライゼーションで方向に使用

### 8.3 モーターとアクチュエーターエラー

### REQ-ERR-041 [重要]
**モーター故障**
- モーターが故障した場合（例: コマンドに応答なし、過電流）、以下を行う:
  1. **緊急停止**（ブレーキ係合）
  2. エラーをログ: `VEH-MOT-001`（重要）
  3. 車両に表示: 「モーター故障。車両無効化。」
  4. TVMに通知: 「車両V123無効化: モーター故障」
  5. 修理まで車両を無効化

**根拠:** 安全に移動できない

### REQ-ERR-042 [高]
**ブレーキ故障**
- ブレーキが係合しない場合、以下を行う:
  1. エラーをログ: `VEH-BRK-001`（重要）
  2. セカンダリブレーキ試行（モーターブレーキ）
  3. セカンダリブレーキ失敗 → ログ、TVMに通知、車両無効化

**根拠:** 安全性重要

### 8.4 電源とバッテリーエラー

### REQ-ERR-043 [重要]
**クリティカルバッテリーレベル**
- バッテリーが10%未満の場合、以下を行う:
  1. 現在のミッション中止（ある場合）
  2. 最寄りの充電ステーションにナビゲート
  3. TVMに通知: 「車両V123低バッテリー、充電に戻る」
  4. バッテリーが5%未満の場合、全非必須システムを無効化（カメラ、ライト）して電力節約

**根拠:** 運用エリアでのバッテリー切れ防止

### REQ-ERR-044 [高]
**バッテリー通信故障**
- バッテリーレベルを読み取れない場合（BMS通信エラー）、以下を行う:
  1. エラーをログ: `VEH-BAT-001`（高）
  2. 最悪ケースを仮定（低バッテリー）
  3. 即座に充電ステーションに帰還
  4. TVMに通知: 「バッテリーセンサー故障、充電に戻る」

**根拠:** バッテリー状態を知らずに運用できない

### 8.5 通信エラー

### REQ-ERR-045 [高]
**TVM接続喪失**
- 車両がTVMへの接続を失った場合（60秒間ハートビートなし）、以下を行う:
  1. 「オフラインモード」に入る
  2. 安全な場合は現在のミッション完了（障害物なし）
  3. ミッション完了時、安全な場所に駐車
  4. 60秒毎にTVM接続を再試行
  5. ミッション更新をローカルにキュー（再接続時にアップロード）

**根拠:** 一時的停止中の自律運用

### REQ-ERR-046 [高]
**永続的TVM接続喪失**
- 車両が30分超TVMに再接続できない場合、以下を行う:
  1. エラーをログ: `VEH-COM-001`（高）
  2. 新規ミッションの受け入れ停止（現在のみ完了）
  3. 車両に表示: 「TVM接続喪失。限定運用。」
  4. アラート送信（代替通信チャネルが利用可能な場合、例: SMS）

**根拠:** 拡張オフライン運用には介入が必要

---

## 9. TVMサーバーエラー処理

### 9.1 APIエラー

### REQ-ERR-047 [高]
**API内の未処理例外**
- APIリクエストが未処理例外をスローした場合、以下を行う:
  1. エラーをログ（ERRORレベル）完全なスタックトレース付き
  2. HTTP 500 Internal Server Errorを返す
  3. 応答本文: `{"error": "内部サーバーエラー", "code": "TVM-INT-001", "request_id": "abc123"}`
  4. スタックトレースをクライアントに公開しない（セキュリティリスク）
  5. アラート: エラー率が10/分超の場合、オンコールエンジニアにページ

**根拠:** 内部を公開せずにデバッグ可能性

### REQ-ERR-048 [高]
**リクエストタイムアウト**
- APIリクエストがタイムアウトより長くかかる場合（例: 30秒）、以下を行う:
  1. リクエスト中止
  2. HTTP 504 Gateway Timeoutを返す
  3. エラーをログ: `TVM-TMO-001`（高）
  4. クライアント再試行（指数バックオフ）

**根拠:** クライアントが無期限にハングするのを防止

### REQ-ERR-049 [中]
**レート制限超過**
- クライアントがレート制限を超えた場合（例: 100 req/分超）、以下を行う:
  1. HTTP 429 Too Many Requestsを返す
  2. ヘッダー: `Retry-After: 60`（レート制限リセットまでの秒数）
  3. 応答本文: `{"error": "レート制限超過", "code": "TVM-RLM-001"}`
  4. ログ: クライアント毎のレート制限違反数

**根拠:** 乱用、DDoSから保護

### 9.2 データベースエラー

### REQ-ERR-050 [重要]
**データベース接続喪失**
- リクエスト中にデータベース接続が失われた場合、以下を行う:
  1. 接続を再試行（最大3回、1秒間隔）
  2. 再接続成功 → クエリ再試行
  3. 再接続失敗 → HTTP 503 Service Unavailableを返す
  4. エラーをログ: `TVM-DB-001`（重要）
  5. アラート: 即座にオンコールエンジニアにページ

**根拠:** データベースは全運用に重要

### REQ-ERR-051 [高]
**クエリタイムアウト**
- データベースクエリがタイムアウトを超えた場合（例: 10秒）、以下を行う:
  1. クエリをキャンセル（PostgreSQL: `pg_cancel_backend`）
  2. 遅いクエリをログ（WARNINGレベル）クエリテキストと期間付き
  3. HTTP 504 Gateway Timeoutをクライアントに返す
  4. アラート: 遅いクエリが5/分超の場合、データベース性能を調査

**根拠:** 遅いクエリがリクエストをブロックするのを防止

### REQ-ERR-052 [高]
**制約違反**
- データベース制約違反（外部キー、ユニーク、not null）の場合、以下を行う:
  1. 例外をキャッチ（例: `IntegrityError`）
  2. ユーザーフレンドリーなメッセージに変換:
     - 外部キー違反 → 「参照アイテムが見つかりません」
     - ユニーク違反 → 「アイテムは既に存在します」
     - Not null違反 → 「必須フィールド不足」
  3. HTTP 400 Bad Requestまたは409 Conflictを返す
  4. エラーをログ: `TVM-DB-002`（中）

**根拠:** データ整合性

### REQ-ERR-053 [中]
**デッドロック検出**
- データベースデッドロックが検出された場合、以下を行う:
  1. トランザクションを再試行（最大3回）
  2. 再試行失敗 → HTTP 500 Internal Server Errorを返す
  3. エラーをログ: `TVM-DB-003`（中）クエリ詳細付き

**根拠:** 一時的同時実行問題

### 9.3 サービスエラー

### REQ-ERR-054 [高]
**Redisキャッシュ利用不可**
- Redis利用不可（接続拒否）の場合、以下を行う:
  1. エラーをログ: `TVM-RDS-001`（高）
  2. フォールバック: データベースに直接クエリ（キャッシュバイパス）
  3. 性能低下（応答時間遅延）
  4. アラート: オンコールエンジニアにページ（Redisは性能に重要）

**根拠:** キャッシュ故障が停止を引き起こさない

### REQ-ERR-055 [中]
**メッセージキュー故障**
- メッセージキュー（例: RabbitMQ）利用不可の場合、以下を行う:
  1. エラーをログ: `TVM-MQ-001`（中）
  2. フォールバック: タスクを同期的に処理（遅いが機能的）
  3. アラート: 運用チームに通知

**根拠:** 非同期処理は優雅に劣化

---

## 10. ネットワークエラー処理

### REQ-ERR-056 [高]
**接続タイムアウト**
- 全ネットワークリクエストにタイムアウトを設定（例: 10秒）
- タイムアウト超過の場合、以下を行う:
  1. リクエスト中止
  2. エラーをログ: `NET-TMO-001`
  3. 指数バックオフで再試行（一時的な場合）

**根拠:** 応答しないサーバーでハングするのを防止

### REQ-ERR-057 [高]
**DNS解決失敗**
- DNS検索が失敗した場合（例: `api.tvm.example.com`を解決できない）、以下を行う:
  1. エラーをログ: `NET-DNS-001`（高）
  2. 再試行（最大3回）
  3. 永続的 → アラート（DNSプロバイダー問題の可能性）

**根拠:** DNS障害は全通信を防止

### REQ-ERR-058 [中]
**SSL/TLS証明書エラー**
- TLS証明書が無効（期限切れ、ホスト名不一致、信頼されないCA）の場合、以下を行う:
  1. 接続を拒否（証明書エラーを無視しない）
  2. エラーをログ: `NET-TLS-001`（中）
  3. アラート: 証明書が間もなく期限切れまたは無効

**根拠:** セキュリティ（MITM攻撃防止）

### REQ-ERR-059 [中]
**パケット損失/高レイテンシー**
- 高パケット損失（5%超）またはレイテンシー（500ms超）が検出された場合、以下を行う:
  1. 警告をログ: `NET-LAT-001`（中）
  2. 適応: 更新頻度を削減（例: テレメトリを10 Hzから1 Hzへ）
  3. オペレーターに通知: 「ネットワーク劣化、テレメトリ削減」

**根拠:** 貧弱なネットワークでの優雅な劣化

---

## 11. データベースエラー処理

*（セクション9.2も参照）*

### REQ-ERR-060 [重要]
**データベース破損検出**
- データベース破損が検出された場合（チェックサム不一致、無効なページ）、以下を行う:
  1. **破損データベースへの書き込みを即座に停止**
  2. エラーをログ: `DB-COR-001`（重要）
  3. 災害復旧計画を起動（バックアップから復元）
  4. アラート: DBAとDRチームにページ

**根拠:** さらなるデータ損失を防止

### REQ-ERR-061 [高]
**ディスク満杯**
- データベースディスクが満杯（書き込み不可）の場合、以下を行う:
  1. エラーをログ: `DB-DSK-001`（高）
  2. 書き込みリクエストの受け入れ停止（HTTP 503を返す）
  3. アラート: 即座に運用チームにページ
  4. 軽減策: 古いログを削除、バックアップローテーション、ディスク拡張

**根拠:** データベースクラッシュ防止

### REQ-ERR-062 [中]
**レプリケーションラグ**
- スタンバイデータベースレプリケーションラグが5分超の場合、以下を行う:
  1. 警告をログ: `DB-REP-001`（中）
  2. アラート: DBAに通知（性能問題を調査）
  3. プライマリから読み取りクエリ継続（ラグが許容できない場合）

**根拠:** データ一貫性

---

## 12. ユーザー向けエラーメッセージ

### REQ-ERR-063 [高]
**明確なエラーメッセージ**
- ユーザーへのエラーメッセージは以下でなければならない:
  - **明確:** 何が起こったかを平易な言葉で説明
  - **実用的:** ユーザーが何をできるかを伝える
  - **非技術的:** スタックトレース、エラーコードなし（「詳細を表示」オプションを除く）

**良い例:**
```
「ミッションを作成できません。ピックアップ場所'ビルX'が見つかりませんでした。
場所名を確認して再試行してください。」
```

**悪い例:**
```
「NullPointerException: location.getCoordinates() returned null at MissionService.java:142」
```

### REQ-ERR-064 [高]
**エラーメッセージローカライゼーション**
- エラーメッセージはローカライズしなければならない（英語、日本語）
- i18nフレームワークを使用（例: フロントエンド用i18next）
- エラーコードを使用してローカライズメッセージを検索

**例:**
```javascript
// エラーコード: API-VAL-001
// 英語: "Invalid pickup location"
// 日本語: "ピックアップ場所が無効です"
```

### REQ-ERR-065 [中]
**段階的開示**
- デフォルトでユーザーフレンドリーなメッセージを表示
- 上級ユーザー/サポート用に「技術的詳細を表示」オプションを提供
- 技術的詳細: エラーコード、リクエストID、タイムスタンプ

**UI例:**
```
[ ! ] ミッションを作成できません。サポートに連絡してください。

[詳細を表示 ▼]
  エラーコード: TVM-DB-002
  リクエストID: abc123
  タイムスタンプ: 2025-12-17 10:30:00 UTC
```

### REQ-ERR-066 [中]
**エラーヘルプリンク**
- 一般的なエラーはヘルプリンクを含むべき
- リンク先: FAQ、トラブルシューティングガイド、サポート連絡

**例:**
```
「ログイン失敗。メールとパスワードを確認してください。
[ヘルプが必要？パスワードリセット](https://help.tvm.example.com/reset-password)」
```

---

## 13. 安全性重要エラー処理

### REQ-ERR-067 [重要]
**緊急停止オーバーライド**
- 緊急停止ボタンは全ソフトウェアコマンドをオーバーライドしなければならない
- ハードウェアレベルキルスイッチ（モーター電源カット）
- ソフトウェアで無効化不可（安全要件ISO 13849）

**根拠:** 究極の安全メカニズム

### REQ-ERR-068 [重要]
**安全PLC監視**
- 安全PLCはROS 2システムヘルスを監視しなければならない
- ROS 2システムが応答しない場合（5秒間ハートビートなし）、PLCが緊急停止をトリガー
- 安全PLCは独立動作（別マイクロコントローラー）

**根拠:** ソフトウェアクラッシュ時のフェイルセーフ

### REQ-ERR-069 [重要]
**障害物検出冗長性**
- 障害物検出は冗長センサーを使用しなければならない（LiDAR + カメラ）
- 両センサーが障害物を検出 → 停止必須（オーバーライドなし）
- センサーが不一致（一方が検出、他方が検出しない） → 停止（安全仮定）

**根拠:** 偽陰性防止（障害物見逃し）

### REQ-ERR-070 [重要]
**速度制限適用**
- ソフトウェア速度制限: 乗客搭乗時1.5 m/s、空時2.0 m/s
- ハードウェア速度制限: 2.5 m/s（絶対最大、モーターコントローラーで適用）
- ソフトウェアはハードウェア制限を超えてはならない（安全チェック）

**根拠:** 暴走車両防止

---

## 14. エラー伝播と境界

### REQ-ERR-071 [高]
**フロントエンドのエラー境界**
- フロントエンド（React）はエラー境界を使用しなければならない
- コンポーネントがクラッシュした場合、フォールバックUIを表示（空白ページではない）
- フォールバックUI: 「問題が発生しました。[ページ再読み込み]」
- エラーをバックエンドにログ（監視用）

**根拠:** UIクラッシュがアプリ全体の障害を引き起こさない

### REQ-ERR-072 [高]
**APIエラー境界**
- 各APIエンドポイントはトップレベルエラーハンドラーを持たなければならない
- 全未処理例外をキャッチ、HTTP 500を返す
- 例外がサーバー全体をクラッシュさせるのを防止

**例（Node.js/Express）:**
```javascript
app.use((err, req, res, next) => {
  logger.error('未処理エラー', { error: err, requestId: req.id });
  res.status(500).json({ error: '内部サーバーエラー', code: 'TVM-INT-001' });
});
```

### REQ-ERR-073 [中]
**ROS 2ノードエラー処理**
- 各ROS 2ノードはコールバック内で例外をキャッチしなければならない
- 例外がノード全体をクラッシュさせない
- エラーをログ、メッセージをスキップ、処理継続

**例（Python）:**
```python
def callback(msg):
    try:
        process_message(msg)
    except Exception as e:
        self.get_logger().error(f'メッセージ処理エラー: {e}')
        # 継続（ノードをクラッシュさせない）
```

---

## 15. タイムアウト処理

### REQ-ERR-074 [高]
**全I/Oにタイムアウトを設定**
- 全I/O操作（ネットワーク、ディスク、データベース）はタイムアウトを持たなければならない
- 無期限ブロッキングを防止
- タイムアウト値:
  - データベースクエリ: 10秒
  - HTTPリクエスト: 30秒
  - ファイル読み取り: 5秒
  - ROSサービスコール: 5秒

**根拠:** 応答性、ハング防止

### REQ-ERR-075 [高]
**ミッションタイムアウト**
- ミッションは推定期間に基づくタイムアウトを持たなければならない
- タイムアウト = 推定期間 × 2（遅延バッファ）
- タイムアウト内にミッション未完了の場合、中止して調査

**根拠:** スタックミッション検出

### REQ-ERR-076 [中]
**アイドル接続タイムアウト**
- 5分超アイドルのデータベース接続はクローズしなければならない
- リソース枯渇防止（接続プールリーク）

**根拠:** リソース管理

---

## 16. リソース枯渇処理

### REQ-ERR-077 [重要]
**メモリ制限適用**
- システムはメモリ使用を監視しなければならない
- メモリ使用が90%超の場合、以下を行う:
  1. 警告をログ: `SYS-MEM-001`（高）
  2. ガベージコレクションをトリガー（該当する場合）
  3. メモリが95%超の場合、新規リクエストを拒否（HTTP 503を返す）
  4. アラート: 運用チームにページ

**根拠:** メモリ不足クラッシュ防止

### REQ-ERR-078 [高]
**ディスク容量監視**
- システムはディスク容量を監視しなければならない
- ディスクが90%超満杯の場合、以下を行う:
  1. 警告をログ: `SYS-DSK-001`（高）
  2. クリーンアップをトリガー（古いログ、一時ファイルを削除）
  3. ディスクが95%超満杯の場合、書き込み受け入れ停止
  4. アラート: 運用チームにページ

**根拠:** ディスク満杯クラッシュ防止

### REQ-ERR-079 [高]
**接続プール枯渇**
- システムはデータベース接続プール使用を監視しなければならない
- 全接続が使用中（プール枯渇）の場合、以下を行う:
  1. 新規リクエストをキュー（タイムアウト付き）
  2. 警告をログ: `SYS-POOL-001`（中）
  3. キュー満杯の場合、リクエスト拒否（HTTP 503）
  4. アラート: 1分超プール枯渇の場合、調査（接続リーク？）

**根拠:** リクエスト飢餓防止

### REQ-ERR-080 [中]
**CPUスロットリング**
- システムはCPU使用を監視しなければならない
- CPUが5分超90%超の場合、以下を行う:
  1. 警告をログ: `SYS-CPU-001`（中）
  2. 非必須タスクを削減（例: テレメトリ圧縮をスキップ）
  3. アラート: 運用チームに通知（スケールアップを検討）

**根拠:** 性能低下防止

---

## 17. エラーシナリオのテスト

### REQ-ERR-081 [高]
**エラー注入テスト**
- システムはエラー注入でテストしなければならない（カオスエンジニアリング）
- シミュレート: ネットワーク障害、データベースクラッシュ、センサー故障
- 検証: システムが優雅にリカバリー、エラーログ、アラートトリガー

**ツール:** Chaos Monkey、Gremlin、カスタムスクリプト

### REQ-ERR-082 [高]
**エラーパスのユニットテスト**
- 全エラー処理コードはユニットテストを持たなければならない
- テスト: 例外スロー → エラーログ、正しい応答返却を検証
- カバレッジ: エラーパスの80%超カバレッジを目指す

**根拠:** エラー処理が機能することを保証

### REQ-ERR-083 [中]
**障害の統合テスト**
- 統合テストは障害シナリオを含まなければならない
- 例: データベース利用不可時のミッション作成テスト（HTTP 503を期待）
- 例: LiDAR故障時の車両ナビゲーションテスト（カメラへのフォールバックを期待）

**根拠:** エンドツーエンドエラー処理を検証

### REQ-ERR-084 [中]
**エラーを伴う負荷テスト**
- 負荷テストはエラーシナリオを含まなければならない（ハッピーパスだけでなく）
- 例: リクエストの10%が失敗（ネットワークエラー、タイムアウト）
- 検証: エラー下の負荷でシステムが安定を維持

**根拠:** ストレス下の耐性

---

## 18. エラー処理アンチパターン（してはいけないこと）

### REQ-ERR-085 [重要]
**空のキャッチブロックなし**
- 空のキャッチブロックで例外を無視してはならない
- 誤り: `try { ... } catch (Exception e) { /* 何もしない */ }`
- 正しい: `try { ... } catch (Exception e) { logger.error("エラー", e); throw; }`

**根拠:** サイレント障害はデバッグ不可能

### REQ-ERR-086 [重要]
**再スローなしのキャッチオール禁止**
- 再スローせずに全例外をキャッチしてはならない（トップレベル境界を除く）
- 誤り: `catch (Exception e) { return null; }`（エラーコンテキスト喪失）
- 正しい: `catch (Exception e) { logger.error("エラー", e); throw new CustomException("失敗", e); }`

**根拠:** エラーコンテキスト保存

### REQ-ERR-087 [高]
**エラーコードのマジックナンバー禁止**
- エラーコードにマジックナンバーを使用してはならない
- 誤り: `if (errorCode == 42) { ... }`
- 正しい: `if (errorCode == ERROR_DATABASE_UNAVAILABLE) { ... }`（定数使用）

**根拠:** 可読性

### REQ-ERR-088 [高]
**エラー処理での早すぎる最適化禁止**
- 性能理由でエラーチェックをスキップしてはならない（ボトルネックが証明されない限り）
- 誤り: 1ms節約のため入力検証をスキップ
- 正しい: 常に検証、他で最適化

**根拠:** 正確性 > 性能

---

## 19. エラー処理メトリクス

### REQ-ERR-089 [高]
**エラー率SLO**
- システムはエラー率を全リクエストの1%未満に維持しなければならない
- 測定: (エラー / 総リクエスト) × 100%
- アラート: 5分超エラー率が5%超の場合、オンコールにページ

**根拠:** サービス品質

### REQ-ERR-090 [中]
**平均検出時間（MTTD）**
- 目標: 1分以内にエラーを検出（監視経由）
- 測定: エラー発生からアラートトリガーまでの時間

**根拠:** 高速検出 = 高速リカバリー

### REQ-ERR-091 [中]
**平均解決時間（MTTR）**
- 目標: 1時間以内に重要なエラーを解決
- 測定: エラー検出からサービス復旧までの時間

**根拠:** ダウンタイム最小化

---

## サマリー

**合計要件:** 91（重要: 24、高: 55、中: 12）

### カテゴリ別要件

| カテゴリ | 数 | 重要 | 高 | 中 |
|----------|-------|----------|------|--------|
| **エラー処理原則** | 8 | 3 | 4 | 1 |
| **エラーカテゴリと分類** | 3 | 0 | 2 | 1 |
| **エラー検出** | 6 | 1 | 4 | 1 |
| **エラー報告とロギング** | 6 | 1 | 4 | 1 |
| **エラーリカバリー戦略** | 6 | 2 | 3 | 1 |
| **優雅な劣化** | 4 | 1 | 2 | 1 |
| **車両エラー処理** | 13 | 5 | 8 | 0 |
| **TVMサーバーエラー処理** | 9 | 1 | 5 | 3 |
| **ネットワークエラー処理** | 4 | 0 | 2 | 2 |
| **データベースエラー処理** | 3 | 1 | 1 | 1 |
| **ユーザー向けエラーメッセージ** | 4 | 0 | 2 | 2 |
| **安全性重要エラー処理** | 4 | 4 | 0 | 0 |
| **エラー伝播と境界** | 3 | 0 | 2 | 1 |
| **タイムアウト処理** | 3 | 0 | 2 | 1 |
| **リソース枯渇処理** | 4 | 1 | 2 | 1 |
| **テストエラーシナリオ** | 4 | 0 | 2 | 2 |
| **エラー処理アンチパターン** | 4 | 2 | 2 | 0 |
| **エラー処理メトリクス** | 3 | 0 | 1 | 2 |

---

## 重要なポイント

1. **フェイルセーフ第一:** 安全性重要エラー（障害物検出、モーター故障）は即座に安全状態をトリガー
2. **自動リカバリー:** 一時的エラーは指数バックオフで再試行、サーキットブレーカーはカスケード障害を防止
3. **優雅な劣化:** 完全な障害ではなく機能削減でシステム継続
4. **ユーザーフレンドリーなエラー:** ユーザーへの明確で実用的なメッセージ（技術的専門用語なし）
5. **包括的ロギング:** 全エラーはデバッグ用のコンテキスト付きでログ
6. **テスト:** エラー注入テストはエラー処理が実際に機能することを保証

---

## 関連文書

- `SECURITY_REQUIREMENTS.md` - セキュリティイベントのエラー処理（侵入、侵害）
- `NONFUNCTIONAL_REQUIREMENTS.md` - 可用性、信頼性要件
- `OBSERVABILITY_ARCHITECTURE.md` - エラーの監視とアラート
- `DISASTER_RECOVERY_PLAN.md` - 壊滅的障害のリカバリー手順

---

**文書メタデータ:**
- **バージョン:** 1.0
- **作成:** 2025-12-17
- **次回レビュー:** 2026-03-17（四半期レビュー）
- **オーナー:** 統合チーム（全チーム）

---

**承認署名:**

| 役割 | 名前 | 署名 | 日付 |
|------|------|-----------|------|
| **プロジェクトリード** | 前田さん | __________ | _______ |
| **車両ソフトウェアリード** | パンカジ | __________ | _______ |
| **TVMリード** | 海野さん | __________ | _______ |

---

*文書の終わり*
