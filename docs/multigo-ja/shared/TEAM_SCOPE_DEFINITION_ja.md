# チームスコープ定義 - 3チーム分離

**ドキュメントタイプ:** スコープ定義と境界
**ステータス:** アクティブ
**バージョン:** 1.0
**日付:** 2025年12月19日
**目的:** チーム間のスコープの混乱と重複を防ぐ

---

## 目次

1. [概要](#1-概要)
2. [チームの責任範囲](#2-チームの責任範囲)
3. [スコープの境界](#3-スコープの境界)
4. [インターフェース契約](#4-インターフェース契約)
5. [決定ツリー](#5-決定ツリー)
6. [よくある質問](#6-よくある質問)
7. [エスカレーションプロセス](#7-エスカレーションプロセス)

---

## 1. 概要

### 1.1 このドキュメントが存在する理由

**問題:**
- 元のドキュメントはハードウェア、ソフトウェア、サーバーの責任範囲が混在
- 誰が何を構築するかが不明確
- 重複作業またはギャップのリスク

**解決策:**
- 明確な境界を持つ3つの独立したチーム
- インターフェース契約が通信を定義
- このドキュメントが曖昧さを解決

### 1.2 3チーム構造

```
┌─────────────────────────────────────────────────────────────┐
│                        プロジェクトスコープ                    │
│                                                              │
│  ┌──────────────────┐  ┌──────────────────┐  ┌────────────┐│
│  │  チーム1: Pankaj │  │  チーム2: Unno   │  │ チーム3:   ││
│  │  車両ソフトウェア│  │  TVMサーバー     │  │ Tsuchiya+  ││
│  │                  │  │                  │  │ Kiril      ││
│  │  ROS 2ノード     │  │  バックエンド+DB │  │ ハードウェア││
│  │  ナビゲーション  │  │  フリートダッシュ│  │ センサー   ││
│  │  制御            │  │  ユーザー管理    │  │ モーター   ││
│  │  TVMクライアント │  │  ミッション派遣  │  │ 電源       ││
│  │  ローカルUI      │  │  WebSocket       │  │ 外装       ││
│  └────────┬─────────┘  └────────┬─────────┘  └──────┬─────┘│
│           │                     │                    │      │
│           └──────────┬──────────┴───────┬────────────┘      │
│                      │                  │                   │
│               ┌──────▼──────┐    ┌──────▼──────┐           │
│               │ TVM API     │    │ ハードウェア-│           │
│               │ インター    │    │ ソフトウェア│           │
│               │ フェース契約│    │ インター    │           │
│               └─────────────┘    │ フェース    │           │
│                                  └─────────────┘           │
└─────────────────────────────────────────────────────────────┘
```

### 1.3 黄金律

**ルール1: 自分のレーンに留まる**
- 自分のスコープ内のタスクのみに取り組む
- 他チーム用のコードを書かない
- 他チームのために決定を下さない

**ルール2: インターフェース契約は法律**
- 調整なしにインターフェースを変更できない
- 両側が変更に同意する必要がある
- すべてのインターフェース変更を文書化

**ルール3: 疑問がある場合は尋ねる**
- このドキュメントの決定ツリーを使用
- まだ不明確な場合は上級者にエスカレーション
- 推測しない - スコープを確認

---

## 2. チームの責任範囲

### 2.1 チーム1: Pankaj（車両ソフトウェア）

**主要責任範囲:** 車両上で動作するソフトウェア

**あなたが構築するもの:**
- ✅ ROS 2ノード（C++およびPython）
- ✅ ナビゲーションシステム（Nav2、NDT位置推定、経路計画）
- ✅ ドッキングコントローラー（ArUcoビジュアルサーボイング）
- ✅ スワーブドライブコントローラー（逆運動学、モーターコマンド）
- ✅ 知覚パイプライン（LiDAR処理、障害物検出）
- ✅ 安全監視（ソフトウェア緊急停止、衝突回避）
- ✅ TVMクライアント（REST API呼び出し、UnnoのサーバーへのWebSocket接続）
- ✅ ローカルUI（車両タッチスクリーン上のReactアプリ）
- ✅ eHMIコントローラー（KirilのESP32へのシリアルコマンド）

**あなたが構築しないもの:**
- ❌ ハードウェアプラットフォーム（Tsuchiyaが構築）
- ❌ センサードライバー（Tsuchiyaが提供、あなたが設定）
- ❌ モーターコントローラー（Tsuchiyaが配線、あなたがコマンド送信）
- ❌ TVMサーバー（Unnoが構築）
- ❌ データベース（Unnoが構築）
- ❌ フリートダッシュボード（Unnoが構築）

**あなたのフォルダ:** `pankaj_vehicle_software/`
**あなたのタイムライン:** 18週間
**あなたの成果物:** 車両を制御する動作するROS 2ソフトウェア

---

### 2.2 チーム2: Unno（TVMサーバー）

**主要責任範囲:** バックエンドサーバーとフリート管理

**あなたが構築するもの:**
- ✅ TVMサーバーバックエンド（REST API + WebSocket）
- ✅ データベース（PostgreSQL/MySQL/MongoDB - あなたの選択）
- ✅ ユーザー認証（車両とユーザー用のJWT）
- ✅ フリートダッシュボード（React/Vue/Angular - あなたの選択）
- ✅ ミッション派遣システム（ミッション作成、車両への送信）
- ✅ テレメトリー取り込み（車両からのデータ受信）
- ✅ 予約システム（輸送スケジュール）
- ✅ ユーザー管理（管理者、オペレーター、介護者ロール）

**あなたが構築しないもの:**
- ❌ 車両ソフトウェア（Pankajが構築）
- ❌ ROS 2ノード（Pankajが構築）
- ❌ ハードウェアプラットフォーム（Tsuchiyaが構築）
- ❌ 車両側TVMクライアント（Pankajが構築）

**あなたのフォルダ:** `unno_tvm_server/`
**あなたのタイムライン:** 20週間（MVP 15週間 + 高度な機能 5週間）
**あなたの成果物:** フリートを管理する動作するサーバー、ネットワークからアクセス可能

---

### 2.3 チーム3: Tsuchiya + Kiril（ハードウェア）

**主要責任範囲:** 物理プラットフォーム

**Tsuchiya（機械+電気+センサー）:**
- ✅ シャシー設計と製作
- ✅ スワーブドライブモジュール（ステアリング4つ + 駆動モーター4つ）
- ✅ 電源システム（バッテリー、BMS、DC-DCコンバーター）
- ✅ センサー設置（LiDAR、カメラ、IMU、エンコーダー、バンパー）
- ✅ コンピュートプラットフォーム設置（GMKtec Nucbox K6）
- ✅ ケーブル管理と防水処理
- ✅ ROS 2センサードライバー（LiDAR、カメラ、IMU - あなたが設置、Pankajが設定）
- ✅ CANバス配線とモーターコントローラーセットアップ

**Kiril（外装 + eHMI）:**
- ✅ ボディパネルと外装設計
- ✅ eHMIハードウェア（ESP32、WS2812B LED、スピーカー）
- ✅ ESP32ファームウェア（Pankajからのシリアルコマンド受信）
- ✅ 照明（ヘッドライト、テールライト、ウインカー）
- ✅ 保護カバー（LiDAR、カメラ）

**あなたが構築しないもの:**
- ❌ 車両制御ソフトウェア（Pankajが構築）
- ❌ ナビゲーションアルゴリズム（Pankajが構築）
- ❌ TVMサーバー（Unnoが構築）
- ❌ フリートダッシュボード（Unnoが構築）

**あなたのフォルダ:** `tsuchiya_kiril_hardware/`
**あなたのタイムライン:** 16週間（プロトタイプ5週間 + 完成11週間）
**あなたの成果物:** Pankajのソフトウェアが制御する物理プラットフォーム

---

## 3. スコープの境界

### 3.1 車両ソフトウェア vs ハードウェア

**境界の質問:** 「誰がセンサー用のROS 2ドライバーをインストールするか?」

**回答:**
- **Tsuchiya:** 標準ROS 2パッケージをインストール（`apt install ros-humble-velodyne-driver`）
- **Tsuchiya:** センサー仕様を提供（モデル、接続タイプ、I2Cアドレス）
- **Pankaj:** ドライバーパラメータを設定（トピック名、フレームID、キャリブレーション）
- **Pankaj:** ドライバー出力をナビゲーション/知覚パイプラインに統合

**例:**
```
LiDARドライバーのインストール:

Tsuchiyaが行うこと:
- 車両にLiDARを取り付ける
- 電源（12V）とデータ（イーサネット）を接続
- ドライバーをインストール: sudo apt install ros-humble-ouster-ros
- 仕様書をPankajに提供（モデルOS1-64、IP 192.168.1.10）

Pankajが行うこと:
- ドライバー起動ファイルを設定（IPアドレス、トピック名）
- 座標フレームを設定（sensor_frame -> base_link）
- ポイントクラウドを知覚パイプラインに統合
- データ品質をテストし検証
```

---

**境界の質問:** 「誰がモーター制御コードを書くか?」

**回答:**
- **Tsuchiya:** CANバスを配線、モーターコントローラーを設定（CAN ID、ボーレート）
- **Tsuchiya:** CANプロトコル仕様を提供（メッセージフォーマット、単位）
- **Pankaj:** CANメッセージを送信するROSノードを書く（速度コマンド）
- **Pankaj:** スワーブドライブ逆運動学を実装
- **Pankaj:** 安全制限を実装（最大速度、加速度）

**例:**
```
モーター制御:

Tsuchiyaが行うこと:
- CANバスを配線（ツイストペア、120Ω終端）
- モーターコントローラー1をCAN ID 0x101で設定
- 文書化: 「2バイト送信、バイト0 = 速度（-127から+127）、バイト1 = チェックサム」

Pankajが行うこと:
- /control/swerve/drive_velocitiesをサブスクライブするROSノードを書く
- m/sをモーターコントローラー単位（-127から+127）に変換
- python-canライブラリ経由でCANメッセージを送信
- クローズドループ制御のためにエンコーダーフィードバックを監視
```

---

**境界の質問:** 「誰が緊急停止を処理するか?」

**回答:**
- **Tsuchiya:** ハードウェア緊急停止回路を配線（デュアルチャネル、モーター電源を遮断）
- **Tsuchiya:** 緊急停止ステータスをGPIOピンに接続
- **Pankaj:** GPIOピンを読み取り、/safety/estopトピックを公開
- **Pankaj:** ソフトウェア応答を実装（すべてのコマンドを停止、ミッションをキャンセル）
- **両方:** 一緒にテスト（緊急停止を押す → 100ms以内にモーターが停止）

---

### 3.2 車両ソフトウェア vs TVMサーバー

**境界の質問:** 「誰がユーザー認証を実装するか?」

**回答:**
- **Unno:** ユーザー認証を実装（ダッシュボード用のユーザー名/パスワードログイン）
- **Unno:** 車両とユーザーの両方用のJWTトークンを生成
- **Pankaj:** 車両認証を実装（vehicle_id + api_key → JWTトークン）
- **Pankaj:** 車両にJWTトークンを保存、APIリクエストで送信

**例:**
```
車両認証:

Unnoが行うこと:
- POST /api/v1/auth/loginエンドポイントを作成
- データベースに対してvehicle_idとapi_keyを検証
- JWTトークンを生成（有効期限: 1時間）
- 車両にトークンを返す

Pankajが行うこと:
- 車両起動時にログインリクエストを送信
- トークンをメモリに保存
- すべてのAPIリクエストにトークンを含める（Authorization: Bearer <token>）
- 有効期限前にトークンを更新
```

---

**境界の質問:** 「誰がミッションウェイポイントを決定するか?」

**回答:**
- **Unno:** オペレーターがピックアップ/ドロップオフ場所を選択するためのUIを提供
- **Unno:** ミッションをデータベースに保存
- **Unno:** WebSocket経由で車両にミッションウェイポイントを送信
- **Pankaj:** ミッションを受信、ウェイポイントを検証（マップ境界内）
- **Pankaj:** ウェイポイント間の経路を計画（Nav2を使用）
- **Pankaj:** ナビゲーションを実行、Unnoにステータス更新を送信

**例:**
```
ミッション派遣:

Unnoが行うこと:
- オペレーターがダッシュボードで「ピックアップ: 建物A、ドロップオフ: 建物B」をクリック
- 場所をウェイポイントに変換: [{x: 10, y: 5}, {x: 15, y: 8}]
- WebSocket経由で送信: {"type": "mission.dispatch", "waypoints": [...]}

Pankajが行うこと:
- WebSocketメッセージを受信
- ウェイポイントを検証（マップ内、到達可能かチェック）
- Nav2を使用して経路を計画（障害物、スムージングを処理）
- ナビゲーションを実行（モーターに速度コマンドを送信）
- ステータス更新を送信: 「navigating」、「arrived」、「completed」
```

---

### 3.3 ハードウェア vs TVMサーバー

**境界の質問:** 「ハードウェアとサーバーチームは相互作用するか?」

**回答:** いいえ - Pankajの車両ソフトウェアを通じてのみ通信

**例:**
```
センサーデータフロー:

Tsuchiya → Pankaj → Unno

Tsuchiya:
- LiDARが/sensors/lidar/pointsを公開（ROSトピック）

Pankaj:
- ナビゲーション用にLiDARデータを読み取り（ローカル処理）
- 位置推定から車両位置を抽出
- REST API経由でTVMに位置を送信

Unno:
- POST /api/v1/telemetry経由でテレメトリーを受信
- データベースに保存
- ダッシュボードに表示

TsuchiyaとUnnoは直接通信しない。
```

---

## 4. インターフェース契約

### 4.1 重要なインターフェースドキュメント

**これらのドキュメントがチームの境界を定義:**

| インターフェース | チーム | ドキュメント | ステータス |
|-----------------|--------|--------------|-----------|
| **TVM API** | Pankaj ↔ Unno | `shared/INTERFACES/TVM_API_SPECIFICATION.md` | ✅ 最終 |
| **ハードウェア-ソフトウェア** | Pankaj ↔ Tsuchiya+Kiril | `shared/INTERFACES/HARDWARE_SOFTWARE_INTERFACE.md` | ✅ 最終 |
| **データモデル** | Pankaj ↔ Unno | `shared/INTERFACES/TVM_DATA_MODELS.md` | ✅ 最終 |

**黄金律:** 調整なしにインターフェースを変更できない!

### 4.2 インターフェース変更プロセス

**インターフェースを変更する必要がある場合:**

1. **影響を受けるチームを特定**
   - TVM API変更: Pankaj + Unno
   - ハードウェアインターフェース変更: Pankaj + Tsuchiya

2. **変更を提案**
   - 文書化: 旧仕様 → 新仕様
   - 正当化: なぜ必要か?
   - 影響: 何が壊れるか? 移行パスは?

3. **承認を得る**
   - 両チームが同意する必要がある
   - 大きな変更には上級者の承認
   - インターフェースドキュメントを更新（必要に応じてバージョンアップ）

4. **同時に実装**
   - 両チームが同時にコードを更新
   - 変更後に統合をテスト
   - 下位互換性が必要な場合は移行を文書化

---

## 5. 決定ツリー

### 5.1 「このタスクは誰が行うか?」決定ツリー

```
開始: タスクがあります。誰が行いますか?

├─ 車両上で実行されますか?
│  ├─ はい → ハードウェアまたはソフトウェア?
│  │  ├─ ハードウェア（物理的） → TsuchiyaまたはKiril
│  │  │  ├─ 機械/電気/センサー → Tsuchiya
│  │  │  └─ 外装/eHMI → Kiril
│  │  └─ ソフトウェア（コード） → Pankaj
│  │     ├─ ROS 2ノード → Pankaj
│  │     ├─ 制御アルゴリズム → Pankaj
│  │     ├─ ローカルUI → Pankaj
│  │     └─ TVMクライアント → Pankaj
│  │
│  └─ いいえ → サーバーサイドまたは管理?
│     ├─ サーバーバックエンド → Unno
│     ├─ データベース → Unno
│     ├─ フリートダッシュボード → Unno
│     └─ ユーザー管理 → Unno
│
└─ チーム間のインターフェースですか?
   ├─ はい → 両チームが調整
   │  ├─ まずインターフェースドキュメントを更新
   │  └─ 両チームが同時に実装
   │
   └─ まだ不明確? → 上級者にエスカレーション
```

---

## 6. よくある質問

### Q1: 「他チームが選択したライブラリ/ツールを使用できるか?」

**回答:** はい、ただし調整が必要

**例:**
- PankajがROS 2を使用 → TsuchiyaがコンピュートプラットフォームにROS 2をインストールする必要がある
- UnnoがPostgreSQLを選択 → Pankajは気にしない（サーバー内部）
- Tsuchiyaが特定のLiDARモデルを選択 → Pankajは互換性のあるドライバーを使用する必要がある

**ルール:** チーム境界を超える技術選択には調整が必要

---

### Q2: 「他チームのスコープでバグを見つけた場合はどうするか?」

**回答:** 報告する、自分で修正しない

**プロセス:**
1. バグを文書化（何、どこ、再現方法）
2. 責任チームに通知
3. 緊急の場合は上級者にエスカレーション
4. 責任チームが修正

---

### Q3: 「他チームの作業に改善を提案できるか?」

**回答:** はい！提案は歓迎、ただし実装は彼らの選択

---

### Q4: 「タイムラインが合わない場合はどうするか?」

**回答:** 独立開発のためにモックとスタブを使用

**例:**
- **UnnoのサーバーがPankajより前に準備できていない:** モックTVMサーバーを使用（実装ガイドで提供）
- **TsuchiyaのハードウェアがPankajより前に準備できていない:** ROS 2シミュレーションを使用（Gazebo）
- **PankajのUnnoより前に車両が準備できていない:** モック車両クライアントを使用（実装ガイドで提供）

**ルール:** 他チームをブロックしない - 独立して開発、後で統合

---

### Q5: 「誰が完全なシステムをデプロイするか?」

**回答:** 各チームが自分のコンポーネントをデプロイ

**デプロイメント:**
- **Pankaj:** 車両コンピュート（Nucbox K6）にROS 2ソフトウェアをデプロイ
- **Unno:** クラウド/オンプレミスサーバーにTVMサーバーをデプロイ
- **Tsuchiya+Kiril:** 物理プラットフォームを組み立て

**統合テスト:** 第12-15週（すべてのチームが一緒に）

---

## 7. エスカレーションプロセス

### 7.1 いつエスカレーションするか

**以下の場合に上級者にエスカレーション:**
- このドキュメントをチェックした後もスコープの境界が不明確
- インターフェース変更に大きな再設計が必要
- チームがタスクの所有者について意見が一致しない
- タイムラインの競合（ブロックする依存関係）
- リソースの競合（予算、機器）

---

## 8. サマリー

### 8.1 主要原則

**1. 明確な境界**
- 各チームは自分のスコープに対して独占的責任を持つ
- 重複なし、ギャップなし

**2. インターフェース契約**
- チームは定義されたインターフェースを介して通信
- インターフェースは調整なしに変更できない

**3. 独立開発**
- チームはモックを使用して並行作業
- 統合は定義されたマイルストーンで発生

**4. 必要に応じてエスカレーション**
- 推測しない - 尋ねて確認
- 上級者が紛争を解決

### 8.2 クイックリファレンステーブル

| 質問 | チーム |
|------|-------|
| ナビゲーションアルゴリズム | Pankaj |
| モーター配線 | Tsuchiya |
| ユーザーログイン（ダッシュボード） | Unno |
| ドッキングコントローラー | Pankaj |
| バッテリー設置 | Tsuchiya |
| データベーススキーマ | Unno |
| ROS 2ノード | Pankaj |
| LED配線 | Kiril |
| ESP32ファームウェア | Kiril |
| TVMクライアント（車両側） | Pankaj |
| TVMサーバー（バックエンド） | Unno |
| フリートダッシュボード | Unno |
| シャシー製作 | Tsuchiya |
| センサーキャリブレーション（ソフトウェア） | Pankaj |
| センサー設置（ハードウェア） | Tsuchiya |

### 8.3 成功基準

**正しくスコープに従っている場合:**
- ✅ 自分のフォルダ内のタスクのみに取り組む
- ✅ 他チームとインターフェース変更を調整
- ✅ 他チームを待っている間はモックを使用
- ✅ 不明確なスコープの質問をエスカレーション
- ✅ READMEファイルに記載されているものを提供

**注意信号（スコープ違反）:**
- ❌ 他チームのフォルダでコードを書く
- ❌ 調整なしにインターフェースを変更
- ❌ 他チームを待ってブロックされている（モックを使用すべき）
- ❌ 他チームのスコープ内の機能を実装
- ❌ 他チームのために決定を下す

---

## 9. ドキュメント履歴

**バージョン1.0（2025年12月19日）:**
- 初期スコープ定義
- 3チーム分離（Pankaj、Unno、Tsuchiya+Kiril）
- インターフェース契約定義
- 決定ツリー作成
- よくある質問に回答

**承認:**
- 上級者: [保留中]
- Pankaj: 確認済み
- Unno: [保留中]
- Tsuchiya: [保留中]
- Kiril: [保留中]

---

**ドキュメントステータス:** ✅ チームレビュー準備完了
**場所:** `shared/TEAM_SCOPE_DEFINITION.md`
**適用対象:** すべての3チーム

**次のステップ:**
1. すべてのチームがこのドキュメントをレビュー
2. すべてのチームがスコープ理解を確認
3. 上級者がスコープ境界を承認
4. 独立開発を開始

---

**スコープ定義の終わり**
